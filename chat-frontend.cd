hooks/use-websocket.ts

import { useEffect, useRef, useState, useCallback } from 'react';
import { useAuthStore } from '@/lib/stores/auth-store';
import { useChatStore } from '@/lib/stores/chat-store';
import { processWebSocketMessage, processOutgoingMessage, handleSpecialMessageTypes } from '@/lib/utils/websocket-processor';
import toast from 'react-hot-toast';

interface WebSocketMessage {
  type: string;
  data: any;
  timestamp: number;
}

export const useWebSocket = (roomId?: string) => {
  const [isConnected, setIsConnected] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected'>('disconnected');
  const wsRef = useRef<WebSocket | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const { token } = useAuthStore();

  const connect = useCallback(() => {
    if (!token) {
      console.log('‚ùå WebSocket: No token available for connection');
      return;
    }

    setConnectionStatus('connecting');
    
    // Global admin connection - no room_id parameter to receive messages from ALL rooms
    let wsUrl = `${process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:9090'}/ws/chat?token=${encodeURIComponent(token)}`;
    
    // Only add room_id if specifically connecting to a single room (not recommended for dashboard)
    if (roomId) {
      wsUrl += `&room_id=${encodeURIComponent(roomId)}`;
      console.log('üîå WebSocket: Connecting to specific room:', roomId);
    } else {
      console.log('üîå WebSocket: Connecting globally to receive messages from ALL rooms');
    }

    console.log('üîå WebSocket: Connecting to:', wsUrl.replace(/token=[^&]+/, 'token=***'));
    const ws = new WebSocket(wsUrl);
    wsRef.current = ws;

    ws.onopen = () => {
      console.log('‚úÖ WebSocket connected successfully');
      setIsConnected(true);
      setConnectionStatus('connected');
      
      // Clear any existing reconnect timeout
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
        reconnectTimeoutRef.current = null;
      }
      
      if (roomId) {
        console.log(`üì§ Connected to specific room: ${roomId}`);
      } else {
        console.log('üì§ Connected globally - will receive messages from all customer rooms');
      }
    };

    ws.onmessage = async (event) => {
      try {
        const message: WebSocketMessage = JSON.parse(event.data);
        console.log('üì® WebSocket message received:', message);
        
        // Process the message to handle room ID mapping
        const processedMessage = await processWebSocketMessage(message);
        
        // Handle the processed message
        handleSpecialMessageTypes(processedMessage);
      } catch (error) {
        console.error('‚ùå Error parsing WebSocket message:', error, 'Raw data:', event.data);
      }
    };

    ws.onerror = (error) => {
      console.error('‚ùå WebSocket error:', error);
      toast.error('Connection error occurred');
    };

    ws.onclose = (event) => {
      console.log('üîå WebSocket disconnected:', event.code, event.reason);
      setIsConnected(false);
      setConnectionStatus('disconnected');
      
      // Attempt to reconnect after 3 seconds
      if (!reconnectTimeoutRef.current) {
        reconnectTimeoutRef.current = setTimeout(() => {
          connect();
        }, 3000);
      }
    };
  }, [token, roomId]);

  // Message handling is now done by handleSpecialMessageTypes in websocket-processor

  const sendMessage = useCallback((type: string, data: any) => {
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      const message = processOutgoingMessage(type, data);
      wsRef.current.send(JSON.stringify(message));
    } else {
      toast.error('Not connected to chat server');
    }
  }, []);

  const sendChatMessage = useCallback((message: string, roomId: string) => {
    sendMessage('chat_message', {
      message,
      room_id: roomId
    });
  }, [sendMessage]);

  const sendTypingIndicator = useCallback((isTyping: boolean, roomId: string) => {
    sendMessage(isTyping ? 'typing_start' : 'typing_stop', {
      room_id: roomId
    });
  }, [sendMessage]);

  const joinRoom = useCallback((roomId: string) => {
    sendMessage('join_room', {
      room_id: roomId
    });
  }, [sendMessage]);

  const leaveRoom = useCallback((roomId: string) => {
    sendMessage('leave_room', {
      room_id: roomId
    });
  }, [sendMessage]);

  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
    
    if (wsRef.current) {
      wsRef.current.close();
      wsRef.current = null;
    }
  }, []);

  useEffect(() => {
    connect();
    return () => {
      disconnect();
    };
  }, [connect, disconnect]);

  return {
    isConnected,
    connectionStatus,
    sendChatMessage,
    sendTypingIndicator,
    joinRoom,
    leaveRoom,
    disconnect
  };
};



lib/utils/websocket-processor.ts

// WebSocket message processor to handle room ID mapping and message routing

import { handleRoomMapping, isValidUUID } from './room-mapping';
import { useChatStore } from '@/lib/stores/chat-store';
import { toast } from 'sonner';
import { handleSupportChatMessage } from './chat-room-bridge';

interface WebSocketMessage {
  type: string;
  data: any;
  timestamp: number;
  room_id?: string;
}

interface ProcessedMessage extends WebSocketMessage {
  originalRoomId?: string;
  mappedRoomId?: string;
  message?: string;
}

/**
 * Process incoming WebSocket message and handle room ID mapping
 */
export const processWebSocketMessage = async (message: WebSocketMessage) => {
  try {
    console.debug('WS message meta', {
      type: message.type,
      room_id: (message as any).room_id ?? (message as any).roomId,
      timestamp: message.timestamp,
      data: message.data,
    });
    
    // First handle support-chat mapping
    const supportChatProcessed = await handleSupportChatMessage(message);
    
    // Handle specific message types
    if (supportChatProcessed) {
      handleSpecialMessageTypes(supportChatProcessed);
    }
    
    console.log('‚úÖ Processed message:', {
      original: message,
      processed: supportChatProcessed
    });
    
    return supportChatProcessed;
  } catch (error) {
    console.error('‚ùå Error processing WebSocket message:', error);
    return null;
  }
};

/**
 * Process outgoing WebSocket messages to ensure proper room ID format
 */
export const processOutgoingMessage = (
  type: string,
  data: any,
  customerId?: string
): any => {
  const processedData = { ...data };
  
  // Handle room_id in outgoing messages
  if (data.room_id && !isValidUUID(data.room_id) && customerId) {
    // For now, keep the original room_id as the backend should handle mapping
    // This can be enhanced later if needed
  }
  
  return {
    type,
    timestamp: Date.now(),
    ...processedData
  };
};

/**
 * Handle specific message types that need special processing
 */
export const handleSpecialMessageTypes = (message: ProcessedMessage) => {
  console.log('üéØ Handling special message type:', message.type, 'for room:', message.room_id);
  
  const { addMessage, updateTypingStatus, addNotification, addRoom } = useChatStore.getState();
  
  console.log('üîÑ Processing message type:', message.type, 'Data:', message.data);
  
  switch (message.type) {
    case 'chat_message':
      console.log('üì® Processing chat message from backend:', message.data);
      
      // ‚úÖ BACKEND TEAM FIX: Implement proper field access patterns
      // Extract message content from BOTH possible locations
      const messageContent = message.message || message.data?.message || '';
      const senderType = message.data?.sender_type || 'unknown';
      const senderName = message.data?.sender_name || 'Unknown';
      const roomId = message.data?.room_id;
      const messageId = message.data?.message_id;
      const senderId = message.data?.sender_id;
      const timestamp = message.data?.timestamp || message.timestamp || Date.now();
      
      // ‚úÖ CRITICAL DEBUG: Log the extracted content
      console.log('üìù Message content extraction:');
      console.log('  - message.message:', message.message);
      console.log('  - message.data?.message:', message.data?.message);
      console.log('  - Final content:', messageContent);
      console.log('  - Sender type:', senderType);
      console.log('  - Room ID:', roomId);
      
      // ‚úÖ VALIDATION: Check if content is empty
      if (!messageContent || messageContent.trim() === '') {
        console.error('‚ùå FRONTEND ERROR: Message content is empty!');
        console.error('Raw message object:', JSON.stringify(message, null, 2));
        // Still process the message but log the issue
      }
      
      if (message.data && roomId) {
        const { rooms } = useChatStore.getState();
        const existingRoom = rooms.find(room => room.id === roomId);
        
        // If room doesn't exist, create it
        if (!existingRoom && senderType === 'customer') {
          console.log('üè† Creating new room for customer message:', roomId);
          const newRoom = {
            id: roomId,
            name: `Chat with ${senderName}`,
            customer_id: senderId,
            customer_name: senderName,
            status: 'active' as const,
            unread_count: 1,
            created_at: new Date(message.data.created_at || Date.now()).toISOString(),
            updated_at: new Date().toISOString()
          };
          addRoom(newRoom);
        }
        
        // ‚úÖ FIXED: Use extracted content with proper fallback
        const messageToAdd = {
          id: messageId || `msg_${Date.now()}`,
          room_id: roomId,
          sender_id: senderId,
          sender_name: senderName,
          sender_type: senderType,
          message: messageContent, // ‚úÖ Use properly extracted content
          timestamp: timestamp,
          read: false
        };
        
        console.log('‚úÖ Adding message to store:', messageToAdd);
        addMessage(messageToAdd);
        
        // Show notification for new customer messages
        if (senderType === 'customer') {
          toast.success(`New message from ${senderName}`);
          addNotification({
            id: Date.now(),
            type: 'new_message',
            title: 'New Customer Message',
            message: `${senderName}: ${messageContent}`, // ‚úÖ Use extracted content
            roomId: roomId,
            timestamp: Date.now()
          });
        }
      }
      break;
      
    case 'typing_start':
    case 'typing_stop':
      console.log(`‚å®Ô∏è Processing ${message.type} from backend:`, message.data?.sender_name || message.data?.sender_id, 'Room:', message.data?.room_id);
      if (message.data && message.data.sender_id) {
        updateTypingStatus(message.data.sender_id, message.type === 'typing_start');
        console.log(`‚úÖ Updated typing status for ${message.data.sender_name || message.data.sender_id}: ${message.type === 'typing_start' ? 'typing' : 'stopped typing'}`);
      }
      break;
      
    case 'room_created':
      if (message.data && message.data.room) {
        addRoom(message.data.room);
        toast.success(`New support chat created for ${message.data.room.customer_name}`);
      }
      break;
      
    case 'user_joined':
      if (message.data && message.data.user_name) {
        toast.success(`${message.data.user_name} joined the chat`);
      }
      break;
      
    case 'user_left':
      if (message.data && message.data.user_name) {
        toast.info(`${message.data.user_name} left the chat`);
      }
      break;
      
    case 'room_assigned':
      if (message.data && message.data.admin_name) {
        toast.success(`Room assigned to ${message.data.admin_name}`);
      }
      break;
      
    case 'error':
      console.error('WebSocket error:', message.data);
      if (message.data && message.data.message) {
        toast.error(message.data.message);
      }
      break;
      
    default:
      console.log('‚ùì Unknown message type:', message.type, 'Data:', message.data);
      break;
  }
};


lib/utils/chat-room-bridge.ts


// Temporary bridge to handle mobile app "support-chat" room ID mapping
// This helps until the backend is updated to handle the mapping properly

import { chatAPI } from '@/lib/api/chat';
import { useChatStore } from '@/lib/stores/chat-store';
import { ChatRoom } from '@/lib/stores/chat-store';

// Cache for customer room mappings
const customerRoomCache = new Map<string, string>();

/**
 * Create a support room for a customer when they connect with "support-chat"
 * This is a temporary solution until backend handles the mapping
 */
export const createSupportRoomForCustomer = async (customerId: string, customerName?: string): Promise<ChatRoom | null> => {
  try {
    // Check if we already have a room for this customer
    const existingRoomId = customerRoomCache.get(customerId);
    if (existingRoomId) {
      const { rooms } = useChatStore.getState();
      const existingRoom = rooms.find(room => room.id === existingRoomId);
      if (existingRoom) {
        return existingRoom;
      }
    }

    // Try to find existing room for this customer
    const roomsResponse = await chatAPI.getRooms();
    if (roomsResponse.success) {
      const customerRoom = roomsResponse.data.find(room => room.customer_id === customerId);
      if (customerRoom) {
        customerRoomCache.set(customerId, customerRoom.id);
        return customerRoom;
      }
    }

    // Create a new room for this customer
    const createResponse = await chatAPI.findOrCreateRoom(customerId);
    if (createResponse.success && createResponse.data) {
      const newRoom = createResponse.data;
      customerRoomCache.set(customerId, newRoom.id);
      
      // Add to store
      const { addRoom } = useChatStore.getState();
      addRoom(newRoom);
      
      return newRoom;
    }
  } catch (error) {
    console.error('Error creating support room for customer:', error);
  }
  
  return null;
};

/**
 * Handle incoming WebSocket message that might have "support-chat" room_id
 * Extract customer info and create/find proper room
 */
export const handleSupportChatMessage = async (message: any): Promise<any> => {
  // Check if this is a "support-chat" message
  if (message.room_id === 'support-chat' || (message.data && message.data.room_id === 'support-chat')) {
    // Try to extract customer info from the message
    let customerId = message.sender_id || message.data?.sender_id;
    let customerName = message.sender_name || message.data?.sender_name;
    
    if (customerId) {
      // Create or find the proper room
      const room = await createSupportRoomForCustomer(customerId, customerName);
      
      if (room) {
        // Update the message with the proper room ID
        const updatedMessage = { ...message };
        
        if (updatedMessage.room_id === 'support-chat') {
          updatedMessage.room_id = room.id;
        }
        
        if (updatedMessage.data && updatedMessage.data.room_id === 'support-chat') {
          updatedMessage.data = {
            ...updatedMessage.data,
            room_id: room.id
          };
        }
        
        console.log(`Mapped support-chat to room ${room.id} for customer ${customerId}`);
        return updatedMessage;
      }
    }
  }
  
  return message;
};

/**
 * Get the mapped room ID for a customer
 */
export const getCustomerRoomId = (customerId: string): string | null => {
  return customerRoomCache.get(customerId) || null;
};

/**
 * Clear the cache
 */
export const clearCustomerRoomCache = () => {
  customerRoomCache.clear();
};

/**
 * Manually set a customer room mapping
 */
export const setCustomerRoomMapping = (customerId: string, roomId: string) => {
  customerRoomCache.set(customerId, roomId);
};



lib/stores/chat-store.ts


import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

interface ChatMessage {
  id: string;
  room_id: string;
  sender_id: string;
  sender_name: string;
  sender_type: 'customer' | 'admin' | 'super_admin';
  message: string;
  timestamp: number;
  read: boolean;
}

interface ChatRoom {
  id: string;
  name: string;
  customer_id: string;
  customer_name: string;
  assigned_admin_id?: string;
  assigned_admin_name?: string;
  status: 'active' | 'closed' | 'pending';
  unread_count: number;
  last_message?: ChatMessage;
  created_at: string;
  updated_at: string;
}

interface Notification {
  id: number;
  type: 'new_message' | 'room_assigned' | 'user_joined';
  title: string;
  message: string;
  roomId?: string;
  timestamp: number;
  read: boolean;
}

interface ChatState {
  // Rooms
  rooms: ChatRoom[];
  activeRoom: ChatRoom | null;
  
  // Messages
  messages: Record<string, ChatMessage[]>;
  
  // UI State
  typingUsers: Record<string, string[]>;
  notifications: Notification[];
  unreadNotifications: number;
  
  // Actions
  setRooms: (rooms: ChatRoom[]) => void;
  addRoom: (room: ChatRoom) => void;
  updateRoom: (roomId: string, updates: Partial<ChatRoom>) => void;
  setActiveRoom: (room: ChatRoom | null) => void;
  
  addMessage: (message: ChatMessage) => void;
  setMessages: (roomId: string, messages: ChatMessage[]) => void;
  
  updateTypingStatus: (userId: string, isTyping: boolean) => void;
  
  addNotification: (notification: Omit<Notification, 'read'>) => void;
  markNotificationAsRead: (id: number) => void;
  removeNotification: (id: number) => void;
  clearNotifications: () => void;
}

export const useChatStore = create<ChatState>()(devtools((set, get) => ({
  // Initial state
  rooms: [],
  activeRoom: null,
  messages: {},
  typingUsers: {},
  notifications: [],
  unreadNotifications: 0,
  
  // Room actions
  setRooms: (rooms) => set({ rooms }),
  
  addRoom: (room) => set((state) => ({
    rooms: [room, ...state.rooms]
  })),
  
  updateRoom: (roomId, updates) => set((state) => ({
    rooms: state.rooms.map(room => 
      room.id === roomId ? { ...room, ...updates } : room
    ),
    activeRoom: state.activeRoom?.id === roomId 
      ? { ...state.activeRoom, ...updates }
      : state.activeRoom
  })),
  
  setActiveRoom: (room) => set({ activeRoom: room }),
  
  // Message actions
  addMessage: (message) => set((state) => {
    const roomMessages = state.messages[message.room_id] || [];
    const updatedMessages = [...roomMessages, message];
    
    // Update room's last message and unread count
    const updatedRooms = state.rooms.map(room => {
      if (room.id === message.room_id) {
        return {
          ...room,
          last_message: message,
          unread_count: message.sender_type === 'customer' 
            ? room.unread_count + 1 
            : room.unread_count,
          updated_at: new Date().toISOString()
        };
      }
      return room;
    });
    
    return {
      messages: {
        ...state.messages,
        [message.room_id]: updatedMessages
      },
      rooms: updatedRooms
    };
  }),
  
  setMessages: (roomId, messages) => set((state) => ({
    messages: {
      ...state.messages,
      [roomId]: messages
    }
  })),
  
  // Typing actions
  updateTypingStatus: (userId, isTyping) => set((state) => {
    const currentTyping = state.typingUsers[state.activeRoom?.id || ''] || [];
    
    let updatedTyping;
    if (isTyping) {
      updatedTyping = [...currentTyping.filter(id => id !== userId), userId];
    } else {
      updatedTyping = currentTyping.filter(id => id !== userId);
    }
    
    return {
      typingUsers: {
        ...state.typingUsers,
        [state.activeRoom?.id || '']: updatedTyping
      }
    };
  }),
  
  // Notification actions
  addNotification: (notification) => set((state) => ({
    notifications: [{ ...notification, read: false }, ...state.notifications],
    unreadNotifications: state.unreadNotifications + 1
  })),
  
  markNotificationAsRead: (id) => set((state) => ({
    notifications: state.notifications.map(notif => 
      notif.id === id ? { ...notif, read: true } : notif
    ),
    unreadNotifications: Math.max(0, state.unreadNotifications - 1)
  })),
  
  removeNotification: (id) => set((state) => ({
    notifications: state.notifications.filter(notif => notif.id !== id),
    unreadNotifications: state.notifications.find(notif => notif.id === id && !notif.read) 
      ? Math.max(0, state.unreadNotifications - 1)
      : state.unreadNotifications
  })),

  clearNotifications: () => set({
    notifications: [],
    unreadNotifications: 0
  })
})));

export type { ChatMessage, ChatRoom, Notification };

components/chat/chat-window.tsx
'use client';

import React, { useState, useEffect, useRef } from 'react';
import { useQuery } from '@tanstack/react-query';
import { ChatRoom, ChatMessage } from '@/lib/stores/chat-store';
import { useChatStore } from '@/lib/stores/chat-store';
import { useWebSocket } from '@/hooks/use-websocket';
import { chatAPI } from '@/lib/api/chat';
import { Send, User, Clock, CheckCheck } from 'lucide-react';
import toast from 'react-hot-toast';

interface ChatWindowProps {
  room: ChatRoom;
}

export const ChatWindow: React.FC<ChatWindowProps> = ({ room }) => {
  const [message, setMessage] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  const { messages, setMessages, typingUsers } = useChatStore();
  const { sendChatMessage, sendTypingIndicator, joinRoom } = useWebSocket(room.id);
  
  // Fetch messages for the current room
  const { data: messagesData, isLoading } = useQuery({
    queryKey: ['chat-messages', room.id],
    queryFn: () => chatAPI.getMessages(room.id),
    enabled: !!room.id
  });
  
  useEffect(() => {
    if (messagesData?.success) {
      setMessages(room.id, messagesData.data);
    }
  }, [messagesData, setMessages, room.id]);
  
  useEffect(() => {
    // Join the room when component mounts
    joinRoom(room.id);
    
    // Mark room as read
    chatAPI.markAsRead(room.id).catch(console.error);
  }, [room.id, joinRoom]);
  
  useEffect(() => {
    // Scroll to bottom when new messages arrive
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);
  
  const handleSendMessage = async () => {
    if (!message.trim()) return;
    
    const messageText = message.trim();
    setMessage('');
    
    try {
      // Send via WebSocket for real-time delivery
      sendChatMessage(messageText, room.id);
      
      // Also send via REST API as backup
      await chatAPI.sendMessage(room.id, messageText);
    } catch (error) {
      console.error('Failed to send message:', error);
      toast.error('Failed to send message');
    }
  };
  
  const handleTyping = (value: string) => {
    setMessage(value);
    
    if (!isTyping && value.trim()) {
      setIsTyping(true);
      sendTypingIndicator(true, room.id);
    }
    
    // Clear existing timeout
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
    
    // Set new timeout to stop typing indicator
    typingTimeoutRef.current = setTimeout(() => {
      if (isTyping) {
        setIsTyping(false);
        sendTypingIndicator(false, room.id);
      }
    }, 1000);
  };
  
  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };
  
  const formatTime = (timestamp: number) => {
    return new Date(timestamp).toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit'
    });
  };
  
  const roomMessages = messages[room.id] || [];
  if (roomMessages.length > 0) {
    console.debug('ChatWindow sample messages',
      roomMessages.slice(0, 3).map((msg) => ({
        id: msg.id,
        sender_type: (msg as any).sender_type ?? (msg as any).senderType,
        message: (msg.message || '').substring(0, 20) + '...',
      }))
    );
  }
  
  return (
    <div className="flex flex-col h-full">
      {/* Header */}
      <div className="p-4 border-b border-gray-200 bg-white">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <div className="w-10 h-10 bg-blue-500 rounded-full flex items-center justify-center">
              <User className="w-5 h-5 text-white" />
            </div>
            <div>
              <h3 className="font-medium text-gray-900">{room.customer_name}</h3>
              <p className="text-sm text-gray-500">
                {room.status === 'active' ? 'Online' : 'Offline'}
              </p>
            </div>
          </div>
          
          <div className="flex items-center space-x-2">
            <span className={`px-3 py-1 rounded-full text-sm ${
              room.status === 'active' ? 'bg-green-100 text-green-800' :
              room.status === 'pending' ? 'bg-yellow-100 text-yellow-800' :
              'bg-gray-100 text-gray-800'
            }`}>
              {room.status}
            </span>
          </div>
        </div>
      </div>
      
      {/* Messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {isLoading ? (
          <div className="flex justify-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500" />
          </div>
        ) : roomMessages.length === 0 ? (
          <div className="text-center text-gray-500 mt-8">
            <p>No messages yet. Start the conversation!</p>
          </div>
        ) : (
          roomMessages.map((msg: ChatMessage) => (
            <div
              key={msg.id}
              className={`flex ${msg.sender_type === 'admin' ? 'justify-end' : 'justify-start'}`}
            >
              <div className={`max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
                msg.sender_type === 'admin'
                  ? 'bg-blue-500 text-white'
                  : 'bg-gray-200 text-gray-900'
              }`}>
                <p className="text-sm">{msg.message}</p>
                <div className={`flex items-center justify-end space-x-1 mt-1 ${
                  msg.sender_type === 'admin' ? 'text-blue-100' : 'text-gray-500'
                }`}>
                  <Clock className="w-3 h-3" />
                  <span className="text-xs">{formatTime(msg.timestamp)}</span>
                  {msg.sender_type === 'admin' && (
                    <CheckCheck className="w-3 h-3" />
                  )}
                </div>
              </div>
            </div>
          ))
        )}
        
        {/* Typing indicator */}
        {Object.keys(typingUsers).length > 0 && (
          <div className="flex justify-start">
            <div className="bg-gray-200 rounded-lg px-4 py-2">
              <div className="flex space-x-1">
                <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce" />
                <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }} />
                <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }} />
              </div>
            </div>
          </div>
        )}
        
        <div ref={messagesEndRef} />
      </div>
      
      {/* Message Input */}
      <div className="p-4 border-t border-gray-200 bg-white">
        <div className="flex space-x-2">
          <input
            type="text"
            value={message}
            onChange={(e) => handleTyping(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder="Type your message..."
            className="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          />
          <button
            onClick={handleSendMessage}
            disabled={!message.trim()}
            className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          >
            <Send className="w-5 h-5" />
          </button>
        </div>
      </div>
    </div>
  );
};


components/chat/chat-dashboard.tsx

'use client';

import React, { useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import { useChatStore } from '@/lib/stores/chat-store';
import { useWebSocket } from '@/hooks/use-websocket';
import { ChatRoomList } from '@/components/chat/chat-room-list';
import { ChatWindow } from '@/components/chat/chat-window';
import { ChatNotifications } from '@/components/chat/chat-notifications';

import { chatAPI } from '@/lib/api/chat';

export const ChatDashboard: React.FC = () => {
  const { rooms, activeRoom, setRooms, setActiveRoom } = useChatStore();
  // Connect to WebSocket globally (without room ID) to receive messages from ALL rooms
  const { isConnected, connectionStatus } = useWebSocket(); // No roomId parameter = global connection
  
  // Fetch chat rooms
  const { data: roomsData, isLoading } = useQuery({
    queryKey: ['chat-rooms'],
    queryFn: chatAPI.getRooms,
    refetchInterval: 30000 // Refetch every 30 seconds
  });
  
  useEffect(() => {
    if (roomsData?.success) {
      setRooms(roomsData.data);
    }
  }, [roomsData, setRooms]);
  
  return (
    <div className="flex flex-col h-screen bg-gray-100">

      
      <div className="flex flex-1">
        {/* Sidebar - Room List */}
        <div className="w-1/3 bg-white border-r border-gray-200">
        <div className="p-4 border-b border-gray-200">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-semibold text-gray-900">Support Chats</h2>
            <div className={`w-3 h-3 rounded-full ${
              connectionStatus === 'connected' ? 'bg-green-500' :
              connectionStatus === 'connecting' ? 'bg-yellow-500' :
              'bg-red-500'
            }`} title={connectionStatus} />
          </div>
        </div>
        
        <ChatRoomList 
          rooms={rooms}
          activeRoom={activeRoom}
          onRoomSelect={setActiveRoom}
          isLoading={isLoading}
        />
        </div>

        {/* Main Chat Area */}
        <div className="flex-1 flex flex-col">
          {activeRoom ? (
            <ChatWindow room={activeRoom} />
          ) : (
            <div className="flex-1 flex items-center justify-center text-gray-500">
              <div className="text-center">
                <h3 className="text-lg font-medium mb-2">No chat selected</h3>
                <p>Select a chat from the sidebar to start messaging</p>
              </div>
            </div>
          )}
        </div>

        {/* Notifications */}
        <ChatNotifications />
      </div>
    </div>
  );
};

components/chat/chat-room-list.tsx

'use client';

import React from 'react';
import { ChatRoom } from '@/lib/stores/chat-store';
import { MessageCircle, Clock, User } from 'lucide-react';

interface ChatRoomListProps {
  rooms: ChatRoom[];
  activeRoom: ChatRoom | null;
  onRoomSelect: (room: ChatRoom) => void;
  isLoading: boolean;
}

export const ChatRoomList: React.FC<ChatRoomListProps> = ({
  rooms,
  activeRoom,
  onRoomSelect,
  isLoading
}) => {
  if (isLoading) {
    return (
      <div className="p-4">
        <div className="animate-pulse space-y-3">
          {[...Array(5)].map((_, i) => (
            <div key={i} className="h-16 bg-gray-200 rounded-lg" />
          ))}
        </div>
      </div>
    );
  }

  if (rooms.length === 0) {
    return (
      <div className="p-4 text-center text-gray-500">
        <MessageCircle className="w-12 h-12 mx-auto mb-2 text-gray-300" />
        <p>No active chats</p>
      </div>
    );
  }

  const formatTime = (timestamp: number) => {
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    const minutes = Math.floor(diff / 60000);
    
    if (minutes < 1) return 'Just now';
    if (minutes < 60) return `${minutes}m ago`;
    if (minutes < 1440) return `${Math.floor(minutes / 60)}h ago`;
    return date.toLocaleDateString();
  };

  return (
    <div className="overflow-y-auto">
      {rooms.map((room) => (
        <div
          key={room.id}
          onClick={() => onRoomSelect(room)}
          className={`p-4 border-b border-gray-100 cursor-pointer hover:bg-gray-50 transition-colors ${
            activeRoom?.id === room.id ? 'bg-blue-50 border-blue-200' : ''
          }`}
        >
          <div className="flex items-start justify-between">
            <div className="flex items-center space-x-3 flex-1">
              <div className="relative">
                <div className="w-10 h-10 bg-blue-500 rounded-full flex items-center justify-center">
                  <User className="w-5 h-5 text-white" />
                </div>
                {room.status === 'active' && (
                  <div className="absolute -bottom-1 -right-1 w-3 h-3 bg-green-500 rounded-full border-2 border-white" />
                )}
              </div>
              
              <div className="flex-1 min-w-0">
                <div className="flex items-center justify-between">
                  <h3 className="font-medium text-gray-900 truncate">
                    {room.customer_name}
                  </h3>
                  {room.unread_count > 0 && (
                    <span className="bg-red-500 text-white text-xs rounded-full px-2 py-1 min-w-[20px] text-center">
                      {room.unread_count}
                    </span>
                  )}
                </div>
                
                <p className="text-sm text-gray-600 truncate mt-1">
                  {typeof room.last_message === 'string' ? room.last_message : 
                   room.last_message?.message || 'No messages yet'}
                </p>
                
                <div className="flex items-center space-x-2 mt-2">
                  <Clock className="w-3 h-3 text-gray-400" />
                  <span className="text-xs text-gray-500">
                    {formatTime(Number(room.updated_at))}
                  </span>
                  
                  <span className={`text-xs px-2 py-1 rounded-full ${
                    room.status === 'active' ? 'bg-green-100 text-green-800' :
                    room.status === 'pending' ? 'bg-yellow-100 text-yellow-800' :
                    'bg-gray-100 text-gray-800'
                  }`}>
                    {room.status}
                  </span>
                </div>
              </div>
            </div>
          </div>
        </div>
      ))}
    </div>
  );
};

debug-frontend-messages.js

const WebSocket = require('ws');
const fetch = require('node-fetch');

// Debug frontend message processing by simulating the exact flow
async function debugFrontendMessages() {
  console.log('üîç Debugging Frontend Message Processing');
  console.log('=' .repeat(50));
  
  try {
    // Step 1: Authenticate as admin
    console.log('\n1. Authenticating as admin...');
    const loginResponse = await fetch('http://localhost:9090/api/v1/auth/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        email: 'admin@errandshop.com',
        password: 'Admin123!'
      })
    });
    
    const loginData = await loginResponse.json();
    
    if (!loginResponse.ok) {
      console.log('‚ùå Admin login failed:', loginData);
      return;
    }
    
    console.log('‚úÖ Admin authenticated successfully');
    const adminToken = loginData.data?.token || loginData.data?.tokens?.access_token;
    
    // Step 2: Connect as admin (global connection)
    console.log('\n2. Connecting as admin (global connection)...');
    const adminWsUrl = `ws://localhost:9090/ws/chat?token=${adminToken}`;
    const adminWs = new WebSocket(adminWsUrl);
    
    adminWs.on('open', () => {
      console.log('‚úÖ Admin WebSocket connected');
      
      // Step 3: Send a customer message from another connection
      console.log('\n3. Simulating customer message...');
      const customerWsUrl = `ws://localhost:9090/ws/chat?room_id=support-chat&token=${adminToken}`;
      const customerWs = new WebSocket(customerWsUrl);
      
      customerWs.on('open', () => {
        console.log('‚úÖ Customer simulation connected');
        
        // Send message with exact format that should work
        const testMessage = {
          type: 'chat_message',
          data: {
            message: 'This is a test message from customer',
            sender_id: 'test-customer-123',
            sender_name: 'Test Customer',
            sender_type: 'customer',
            room_id: 'support-chat',
            message_id: `test_msg_${Date.now()}`,
            timestamp: Date.now(),
            created_at: new Date().toISOString()
          },
          room_id: 'support-chat',
          timestamp: Date.now()
        };
        
        console.log('üì§ Sending test message:');
        console.log('   Content:', testMessage.data.message);
        console.log('   From:', testMessage.data.sender_name);
        console.log('   Type:', testMessage.data.sender_type);
        
        customerWs.send(JSON.stringify(testMessage));
        
        setTimeout(() => {
          customerWs.close();
          console.log('üîå Customer connection closed');
        }, 1000);
      });
      
      customerWs.on('error', (error) => {
        console.log('‚ùå Customer WebSocket error:', error.message);
      });
    });
    
    adminWs.on('message', (data) => {
      try {
        const message = JSON.parse(data.toString());
        
        console.log('\nüì• ADMIN RECEIVED MESSAGE:');
        console.log('   Raw message type:', message.type);
        console.log('   Raw message data:', JSON.stringify(message.data, null, 2));
        
        // Simulate frontend processing
        if (message.type === 'chat_message' && message.data) {
          console.log('\nüîÑ FRONTEND PROCESSING:');
          console.log('   Message content field:', message.data.message);
          console.log('   Message content type:', typeof message.data.message);
          console.log('   Message content length:', message.data.message ? message.data.message.length : 'N/A');
          console.log('   Sender name:', message.data.sender_name);
          console.log('   Sender type:', message.data.sender_type);
          console.log('   Room ID:', message.data.room_id);
          
          // Check if message content is empty or undefined
          if (!message.data.message || message.data.message.trim() === '') {
            console.log('\n‚ùå ISSUE FOUND: Message content is empty!');
            console.log('   This explains why the dashboard shows empty messages.');
            console.log('   The backend is sending the message but the content field is empty.');
          } else {
            console.log('\n‚úÖ Message content is present and valid!');
            console.log('   Content:', `"${message.data.message}"`);
          }
          
          // Simulate what the frontend would do
          const frontendMessage = {
            id: message.data.message_id || `msg_${Date.now()}`,
            room_id: message.data.room_id,
            sender_id: message.data.sender_id,
            sender_name: message.data.sender_name || 'Customer',
            sender_type: message.data.sender_type,
            message: message.data.message, // This is the key field
            timestamp: message.data.timestamp || Date.now(),
            read: false
          };
          
          console.log('\nüéØ FRONTEND MESSAGE OBJECT:');
          console.log('   ID:', frontendMessage.id);
          console.log('   Room ID:', frontendMessage.room_id);
          console.log('   Sender:', frontendMessage.sender_name);
          console.log('   Type:', frontendMessage.sender_type);
          console.log('   Message:', `"${frontendMessage.message}"`);
          console.log('   Timestamp:', frontendMessage.timestamp);
        }
      } catch (e) {
        console.log('üì• Raw message (parse error):', data.toString());
      }
    });
    
    adminWs.on('error', (error) => {
      console.log('‚ùå Admin WebSocket error:', error.message);
    });
    
    adminWs.on('close', (code, reason) => {
      console.log(`üîå Admin WebSocket closed: ${code} - ${reason}`);
    });
    
    // Close after 10 seconds
    setTimeout(() => {
      adminWs.close();
      console.log('\n‚úÖ Debug session completed!');
      console.log('\nüí° Analysis:');
      console.log('   - Check if message content is being preserved from backend');
      console.log('   - Verify frontend message processing logic');
      console.log('   - Ensure UI components are accessing the correct message field');
    }, 10000);
    
  } catch (error) {
    console.log('‚ùå Debug failed:', error.message);
  }
}

// Run the debug
debugFrontendMessages();